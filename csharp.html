<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="Welcome to Edureka. A blog for coding enthusiasts">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <link rel="stylesheet" href="/css/style4.css">
       <title>Instructor-Led Online Training with 24X7 Lifetime Support | Edureka</title>
    <link rel="icon" type="image/png" href="/Images/image.png">
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <a class="navbar-brand" href="/">Edureka</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="/">Home <span class="sr-only">(current)</span></a>
                

               
               <li class="nav-item">
                    <a class="nav-link" href="/training.html">Corporate Training</a>

                </li>
                
                <li class="nav-item">
                    <a class="nav-link" href="/contact.html">Contact Us</a>
                </li>


            </ul>
            
            <div class="mx-2">
                <button class="btn btn-danger"  ><a href="/form.html"> SignUP</a> </button>
                <!-- <button class="btn btn-danger"><a href="/form/Public/FORM.html">Signup</a></button> -->
            </div>
            <div class="mx-2">
                <button class="btn btn-danger"  ><a href="/login.html">Login</a> </button>
                <!-- <button class="btn btn-danger"><a href="/form/Public/FORM.html">Signup</a></button> -->
        </div>
    </nav>
    <div class="head">
        <h1> C# Programming Language <br><br></h1>
    </div>

    <div class="box1">

        <h2>Introduction</h2><br>
        <img src="/Images/Csharp (1).png" alt=""><br><br>
        C# is a general-purpose, modern and object-oriented programming language pronounced as “C Sharp”. It was developed by Microsoft led by Anders Hejlsberg and his team within the .NET initiative and was approved by the European Computer Manufacturers Association (ECMA) and International Standards Organization (ISO). C# is among the languages for Common Language Infrastructure. C# is a lot similar to Java syntactically and is easy for users who have knowledge of C, C++ or Java. <br><br>
        <h4>
            A tour of the C# language
        </h4>
        <br><br>
        C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language. C# enables developers to build many types of secure and robust applications that run in .NET. C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers. This tour provides an overview of the major components of the language in C# 8 and earlier. If you want to explore the language through interactive examples, try the introduction to C# tutorials.
        <br><br>

C# is an object-oriented, component-oriented programming language. C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components. Since its origin, C# has added features to support new workloads and emerging software design practices. At its core, C# is an object-oriented language. You define types and their behavior.
<br><br>

Several C# features help create robust and durable applications. Garbage collection automatically reclaims memory occupied by unreachable unused objects. Nullable types guard against variables that don't refer to allocated objects. Exception handling provides a structured and extensible approach to error detection and recovery. Lambda expressions support functional programming techniques. Language Integrated Query (LINQ) syntax creates a common pattern for working with data from any source. Language support for asynchronous operations provides syntax for building distributed systems. C# has a unified type system. All C# types, including primitive types such as int and double, inherit from a single root object type. All types share a set of common operations. Values of any type can be stored, transported, and operated upon in a consistent manner. Furthermore, C# supports both user-defined reference types and value types. C# allows dynamic allocation of objects and in-line storage of lightweight structures. C# supports generic methods and types, which provide increased type safety and performance. C# provides iterators, which enable implementers of collection classes to define custom behaviors for client code.
<br><br>

C# emphasizes versioning to ensure programs and libraries can evolve over time in a compatible manner. Aspects of C#'s design that were directly influenced by versioning considerations include the separate virtual and override modifiers, the rules for method overload resolution, and support for explicit interface member declarations.
<br><br>


<h4>.NET architecture</h4>
<br>
<br>
C# programs run on .NET, a virtual execution system called the common language runtime (CLR) and a set of class libraries. The CLR is the implementation by Microsoft of the common language infrastructure (CLI), an international standard. The CLI is the basis for creating execution and development environments in which languages and libraries work together seamlessly.
<br>
<br>

Source code written in C# is compiled into an intermediate language (IL) that conforms to the CLI specification. The IL code and resources, such as bitmaps and strings, are stored in an assembly, typically with an extension of .dll. An assembly contains a manifest that provides information about the assembly's types, version, and culture.
<br><br>

When the C# program is executed, the assembly is loaded into the CLR. The CLR performs Just-In-Time (JIT) compilation to convert the IL code to native machine instructions. The CLR provides other services related to automatic garbage collection, exception handling, and resource management. Code that's executed by the CLR is sometimes referred to as "managed code." "Unmanaged code," is compiled into native machine language that targets a specific platform.
<br><br>

Language interoperability is a key feature of .NET. IL code produced by the C# compiler conforms to the Common Type Specification (CTS). IL code generated from C# can interact with code that was generated from the .NET versions of F#, Visual Basic, C++. There are more than 20 other CTS-compliant languages. A single assembly may contain multiple modules written in different .NET languages. The types can reference each other as if they were written in the same language.
<br><br>

In addition to the run time services, .NET also includes extensive libraries. These libraries support many different workloads. They're organized into namespaces that provide a wide variety of useful functionality. The libraries include everything from file input and output to string manipulation to XML parsing, to web application frameworks to Windows Forms controls. The typical C# application uses the .NET class library extensively to handle common "plumbing" chores.
<br><br>

<h4>
    Hello world
</h4>
The "Hello, World" program is traditionally used to introduce a programming language. Here it is in C#: <br><br>
<img src="/Images/program2.png" alt="">
<br><br>

The "Hello, World" program starts with a using directive that references the System namespace. Namespaces provide a hierarchical means of organizing C# programs and libraries. Namespaces contain types and other namespaces—for example, the System namespace contains a number of types, such as the Console class referenced in the program, and a number of other namespaces, such as IO and Collections. A using directive that references a given namespace enables unqualified use of the types that are members of that namespace. Because of the using directive, the program can use Console.WriteLine as shorthand for System.Console.WriteLine.
<br><br>

The Hello class declared by the "Hello, World" program has a single member, the method named Main. The Main method is declared with the static modifier. While instance methods can reference a particular enclosing object instance using the keyword this, static methods operate without reference to a particular object. By convention, a static method named Main serves as the entry point of a C# program.
<br><br>

The output of the program is produced by the WriteLine method of the Console class in the System namespace. This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.
<br><br>

<h4>Types and variables</h4>

A type defines the structure and behavior of any data in C#. The declaration of a type may include its members, base type, interfaces it implements, and operations permitted for that type. A variable is a label that refers to an instance of a specific type.
<br><br>

There are two kinds of types in C#: value types and reference types. Variables of value types directly contain their data. Variables of reference types store references to their data, the latter being known as objects. With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable. With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for ref and out parameter variables).
<br><br>

An identifier is a variable name. An identifier is a sequence of unicode characters without any whitespace. An identifier may be a C# reserved word, if it's prefixed by @. Using a reserved word as an identifier can be useful when interacting with other languages.
<br><br>

C#'s value types are further divided into simple types, enum types, struct types, nullable value types, and tuple value types. C#'s reference types are further divided into class types, interface types, array types, and delegate types.
<br><br>

C# programs use type declarations to create new types. A type declaration specifies the name and the members of the new type. Six of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, delegate types, and tuple value types. You can also declare record types, either record struct, or record class. Record types have compiler-synthesized members. You use records primarily for storing values, with minimal associated behavior.
<br><br>
<ul>
<li>    A class type defines a data structure that contains data members (fields) and function members (methods, properties, and others). Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</li>
<li>A struct type is similar to a class type in that it represents a structure with data members and function members. However, unlike classes, structs are value types and don't typically require heap allocation. Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type object.</li>
<li>An interface type defines a contract as a named set of public members. A class or struct that implements an interface must provide implementations of the interface's members. An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</li>
<li>A delegate type represents references to methods with a particular parameter list and return type. Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters. Delegates are analogous to function types provided by functional languages. They're also similar to the concept of function pointers found in some other languages. Unlike function pointers, delegates are object-oriented and type-safe.</li>
</ul>
<br>
The class, struct, interface, and delegate types all support generics, whereby they can be parameterized with other types. <br><br>

C# supports single-dimensional and multi-dimensional arrays of any type. Unlike the types listed above, array types don't have to be declared before they can be used. Instead, array types are constructed by following a type name with square brackets. For example, int[] is a single-dimensional array of int, int[,] is a two-dimensional array of int, and int[][] is a single-dimensional array of single-dimensional arrays, or a "jagged" array, of int. <br><br>

Nullable types don't require a separate definition. For each non-nullable type T, there's a corresponding nullable type T?, which can hold an additional value, null. For instance, int? is a type that can hold any 32-bit integer or the value null, and string? is a type that can hold any string or the value null. <br><br>

C#'s type system is unified such that a value of any type can be treated as an object. Every type in C# directly or indirectly derives from the object class type, and object is the ultimate base class of all types. Values of reference types are treated as objects simply by viewing the values as type object. Values of value types are treated as objects by performing boxing and unboxing operations. In the following example, an int value is converted to object and back again to int. <br><br>

<h4>Program structure</h4>
The key organizational concepts in C# are programs, namespaces, types, members, and assemblies. Programs declare types, which contain members and can be organized into namespaces. Classes, structs, and interfaces are examples of types. Fields, methods, properties, and events are examples of members. When C# programs are compiled, they're physically packaged into assemblies. Assemblies typically have the file extension .exe or .dll, depending on whether they implement applications or libraries, respectively. <br><br>

As a small example, consider an assembly that contains the following code: <br><br>
<img src="/Images/program3.png" alt="">
<br><br><br>
The fully qualified name of this class is Acme.Collections.Stack. The class contains several members: a field named _top, two methods named Push and Pop, and a nested class named Entry. The Entry class further contains three members: a property named Next, a property named Data, and a constructor. The Stack is a generic class. It has one type parameter, T that is replaced with a concrete type when it's used. <br><br>

A stack is a "first in - last out" (FILO) collection. New elements are added to the top of the stack. When an element is removed, it's removed from the top of the stack. The previous example declares the Stack type that defines the storage and behavior for a stack. You can declare a variable that refers to an instance of the Stack type to use that functionality. <br><br>

Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata. Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code. <br><br>

Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for #include directives and header files in C#. The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program. For example, this program uses the Acme.Collections.Stack class from the acme.dll assembly: <br><br>
<img src="/Images/program4.png" alt="">
<br><br><br>

To compile this program, you would need to reference the assembly containing the stack class defined in the earlier example. <br><br>

C# programs can be stored in several source files. When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other. Conceptually, it's as if all the source files were concatenated into one large file before being processed. Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant. C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file. <br><br>


<h4>
Overview
</h4>
<ul>
<li>Introduction to .NET Framework</li>
<li>.NET Framework (Basic Architecture and Component Stack)</li>
<li>Managed code and Unmanaged code in .NET</li>
<li>Managed vs Unmanaged Code</li>
<li>CIL or MSIL</li>
<li>.NET Framework Class Library (FCL)</li>
<li>Introduction to C#</li>
<li>Setting up the Environment in C#</li>
<li>How to Install and Setup Visual Studio for C#?</li>
<li>Evolution of C#</li>
<li>Hello World in C#</li>
<li>How to Execute C# Program on cmd (command-line)?</li>
<li>Main Method</li>
<li>Getting Familiar With Visual Studio</li>
<li>Common Language Runtime(CLR)</li>
<li>Architecture of Common Language Runtime (CLR)</li>
<li>JIT(Just-In-Time) Compiler</li>
<li>Garbage Collection</li>
<li>Windows Form Applications</li>
<li>C vs C#</li>
<li>C++ vs C#</li>
<li>Java vs C#</li>
<li>Python vs C#</li>
<li>Interesting Facts about C#</li>
<li>Type System Unification in C# .NET</li>
</ul>
<br>
<h4>
Fundamentals
</h4>
<ul>
<li>Identifiers</li>
<li>Data Types</li>
<li>Variables</li>
<li>Types of Variables</li>
<li>Implicitly Typed Local Variables – var</li>
<li>Dynamic Type in C#</li>
<li>var vs dynamic</li>
<li>Binary Literals and Digit Separators</li>
<li>Scope of Variables</li>
<li>Access Modifiers</li>
<li>Constants or Literals</li>
<li>Operators</li>
<li>Command Line Arguments</li>
<li>Boxing and Unboxing</li>
<li>Boxing vs UnBoxing</li>
<li>Params in C#</li>
<li>Comments in C#</li>
<li>Type Casting or Type Conversion</li>
<li>Enumeration in C#</li>
<li>Properties in C#</li>
<li>Nullable Types</li>
<li>Structures</li>
</ul>
<br>
<h4>
Important Keywords
</h4>
<ul>
<li>Keywords</li>
<li>as Keyword</li>
<li>is Keyword</li>
<li>Is vs As operator keyword</li>
<li>static keyword</li>
<li>typeof Keyword</li>
<li>Difference between readonly and const keyword</li>
<li>ref keyword</li>
</ul>
<br>
<h4>
Control Statements
</h4>
<ul>
<li>Decision-Making Statements</li>
<li>Switch Statement</li>
<li>Loops</li>
<li>Foreach Loop</li>
<li>Jump Statements(Break, Continue, Goto, Return and Throw)</li>
</ul>
<br>
<h4>
OOP Concepts
</h4>
<ul>
<li>Class and Object</li>
<li>Nested Classes</li>
<li>Difference between Class and Structure</li>
<li>Early and Late Binding</li>
<li>Overloading of Constructors</li>
<li>Inheritance in C#</li>
<li>Encapsulation in C#</li>
<li>Abstraction in C#</li>
<li>this keyword</li>
<li>Static Class</li>
<li>Partial Classes</li>
<li>Shallow Copy and Deep Copy</li>
<li>Different ways to create an Object</li>
<li>Object and Collection Initializer</li>
<li>Accessing structure’s elements using Pointers</li>
</ul>
<br>
<h4>
Methods
</h4>
<ul>
<li>Methods</li>
<li>Method Overloading</li>
<li>Method Returning an Object</li>
<li>Method Parameters</li>
<li>Runtime(Dynamic) Polymorphsim</li>
<li>Method Overriding</li>
<li>Method Hiding</li>
<li>Method Overriding vs Method Hiding</li>
<li>Optional Parameters</li>
<li>Different ways to make Method Parameter Optional</li>
<li>Out Parameters with examples</li>
<li>Difference between Ref and Out keywords</li>
<li>Anonymous Method</li>
<li>Partial Methods</li>
<li>Extension Method</li>
<li>Local Function</li>
</ul>
<br>
<h4>
Delegates
</h4>
<ul>
<li>Delegates</li>
<li>Predicate Delegate</li>
<li>Action Delegate</li>
<li>Func Delegate</li>
</ul>
<br>
<h4>
Constructors
</h4>
<ul>
<li>Constructors in C#</li>
<li>Default Constructor</li>
<li>Copy Constructor</li>
<li>Private Constructor</li>
<li>Constructor Overloading</li>
<li>Static Constructors vs Non-Static Constructors</li>
<li>Invoking an overloaded constructor using this keyword</li>
<li>Destructors</li>
</ul>
<br>
<h4>
Arrays
</h4>
<ul>
<li>Arrays</li>
<li>Jagged Arrays</li>
<li>Arrays of Strings</li>
<li>Using foreach loop in arrays</li>
<li>Array Class</li>
<li>Sorting an Array</li>
<li>Length of an Array</li>
<li>Array.BinarySearch() Method</li>
<li>Check if two array objects are equal or not</li>
<li>Number of elements in a specified dimension of an Array</li>
<li>LongLength property of an Array</li>
<li>Rank of an Array</li>
<li>Passing Arrays as Arguments</li>
<li>Implicitly Typed Arrays</li>
<li>Object and Dynamic Arrays</li>
<li>Array IndexOutofRange Exception</li>
<li>Different ways to sort an array in descending order</li>
</ul>
<br>
<h4>
ArrayList
</h4>
<ul>
<li>What is ArrayList?</li>
<li>How to create the ArrayList?</li>
<li>ArrayList Class</li>
<li>Array vs ArrayList</li>
<li>Adding the elements to the end of the ArrayList</li>
<li>Removing all the elements from the ArrayList</li>
<li>Removing a range of elements from the ArrayList</li>
<li>ArrayList to Array Conversion</li>
<li>Copying the entire ArrayList to a 1-D Array</li>
<li>Copying the entire ArrayList to 1-D Array starting at the specified index</li>
<li>Check if two ArrayList objects are equal</li>
</ul>
<br>
<h4>
String
</h4>
<ul>
<li>String</li>
<li>Verbatim String Literal – @</li>
<li>String Class</li>
<li>String Class Properties</li>
<li>How to use strings in switch statement</li>
<li>StringBuilder in C#</li>
<li>String vs StringBuilder</li>
<li>Length of the StringBuilder</li>
<li>Remove all characters from StringBuilder</li>
<li>Check if two StringBuilder objects are Equal</li>
<li>Capacity of a StringBuilder</li>

</ul>
<br>
<h4>
Tuple
</h4>
<ul>
<li>What is Tuple in C#?</li>
<li>Tuple Class</li>
<li>Tuple T1  Class</li>
<li>Tuple T1,T2  Class</li>
<li>Tuple T1,T2,T3  Class</li>
<li>Tuple T1,T2,T3,T4  Class</li>
<li>Tuple T1,T2,T3,T4,T5  Class</li>
<li>Tuple T1,T2,T3,T4,T5,T6  Class</li>
<li>Tuple T1,T2,T3,T4,T5,T6,T7  Class</li>
<li>Tuple T1,T2,T3,T4,T5,T6,T7,TRest  Class</li>
</ul>
<br>
<h4>
ValueTuple
</h4>
<ul>
<li>What is ValueTuple in C#?</li>
<li>ValueTuple Struct</li>
<li>ValueTuple T1 Struct</li>
<li>ValueTuple T1,T2 Struct</li>
<li>ValueTuple T1,T2,T3 Struct</li>
<li>ValueTuple T1,T2,T3,T4 Struct</li>
<li>ValueTuple T1,T2,T3,T4,T5 Struct</li>
<li>ValueTuple T1,T2,T3,T4,T5,T6 Struct</li>
<li>ValueTuple T1,T2,T3,T4,T5,T6,T7 Struct</li>
<li>ValueTuple T1,T2,T3,T4,T5,T6,T7,TRest Struct</li>
</ul>
<br>
<h4>

Indexers & Properties
</h4>
<ul>
<li>Indexers</li>
<li>Multidimensional Indexers</li>
<li>Overloading of Indexers</li>
<li>Properties</li>
<li>Restrictions on Properties</li>
</ul>
<br>
<h4>
Inheritance
</h4>
<ul>
<li>Inheritance in C#</li>
<li>Multilevel Inheritance</li>
<li>Multiple inheritance using interfaces</li>
<li>Inheritance in Constructors</li>
<li>Inheritance in Interfaces</li>
<li>Abstract Classes</li>
<li>Using sealed class to Prevent Inheritance</li>
<li>Object Class</li>
</ul>
<br>
<h4>
Interfaces
</h4>
<ul>
<li>Interface in C#</li>
<li>How to use Interface References</li>
<li>How to Implement Multiple Interfaces Having Same Method Name</li>
<li>Difference between Abstract Class and Interface</li>
<li>Delegates vs Interfaces</li>
<li>Explicit Interface Implementation</li>
</ul>
<br>
<h4>
Multithreading
</h4>
<ul>
<li>Introduction to Multithreading</li>
<li>Types of Threads</li>
<li>How to create Threads</li>
<li>Main Thread</li>
<li>Lifecycle and States of a Thread</li>
<li>Thread Class</li>
<li>Scheduling a thread for Execution</li>
<li>Check whether a Thread is Alive or not</li>
<li>Joining Threads</li>
<li>Terminating a Thread</li>
<li>Check whether a thread is a background thread or not</li>
<li>Naming a thread and fetching name of current thread</li>
<li>Thread Priority in Multithreading</li>
</ul>
<br>
<h4>
Exception Handling
</h4>
<ul>
<li>Exceptions</li>
<li>System Level Exception vs Application Level Exception</li>
<li>How to use Multiple Catch Clause</li>
<li>Nesting of try and catch blocks</li>
<li>Using finally</li>
</ul>
<br>
<h4>
Collections & Generics
</h4>
<ul>
<li>List</li>
<li>SortedList with Examples</li>
<li>HashSet</li>
<li>SortedSet</li>
<li>Dictionary with Examples</li>
<li>SortedDictionary</li>
<li>Hashtable with Examples</li>
<li>Stack with Examples</li>
<li>Queue with Examples</li>
<li>LinkedList</li>
<li>Hashtable vs Dictionary</li>
<li>SortedList vs SortedDictionary</li>
</ul>
<br>
<h4>
Collections Namespace
</h4>
<ul>
<li>C# | Stack Class</li>
<li>C# | Queue Class</li>
<li>C# | Array Class</li>
<li>C# | ArrayList Class</li>
<li>C# | Hashtable Class</li>
<li>C# | BitArray Class</li>
<li>C# | SortedList Class</li>
</ul>
<br>
<h4>
Generic Namespace
</h4>
<ul>
<li>C# | HashSet T  Class</li>
<li>C# | LinkedList T  Class</li>
<li>C# | List T  Class</li>
<li>C# | SortedSet T  Class</li>
<li>Dictionary Class</li>
<li>SortedDictionary Class</li>
</ul>
<br>
<h4>
System Namespace
</h4>
<ul>
<li>BitConverter Class</li>
<li>Console Class</li>
<li>Convert Class</li>
<li>Decimal Struct</li>
<li>Byte Struct</li>
<li>Char Struct</li>
<li>Int16 Struct</li>
<li>Int32 Struct</li>
<li>Int64 Struct</li>
<li>UInt16 Struct</li>
<li>UInt32 Struct</li>
<li>UInt64 Struct</li>
</ul>
<br>
<h4>
Specialized Namespace
</h4>
<ul>
<li>C# | ListDictionary Class</li>
<li>C# | StringCollection Class</li>
<li>C# | OrderedDictionary Class</li>
<li>C# | HybridDictionary Class</li>
<li>C# | StringDictionary Class</li>
</ul>
<br>
<h4>
What’s New in C# 8.0
</h4>
<ul>
<li>Static Local Function</li>
<li>Range and Indices</li>
<li>Range Structure</li>
<li>Index Struct</li>
</ul>
<br>
<h4>
Windows Forms
</h4>
<ul>
<li>What is Windows Forms(WF) in C#?</li>
<li>Button Control</li>
<li>Label Control</li>
<li>RadioButton Control</li>
<li>CheckBox Control</li>
<li>TextBox Control</li>
<li>ComboBox Control</li>
<li>ToolTip Class</li>
<li>RichTextBox Class</li>
<li>MaskedBox Class</li>
<li>NumericUpDown Class</li>
<li>DateTimePicker Class</li>
<li>ListBox Class</li>
<li>GroupBox Class</li>
<li>FlowLayoutPanel Class</li>
</ul>
<br>
        <b>For More Details Read Documentation:


            <a href="https://docs.microsoft.com/en-us/dotnet/csharp/">Documentation</a></b>

    </div>


  
    <footer class="container">
        <p class="float-right"><a href="#">Back to top</a></p>
        <p>© 2022-2023 Edureka, Inc. · <a href="#">Privacy</a> · <a href="#">Terms</a>
        </p>
    </footer>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
        integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
        integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
        crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
        integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
        crossorigin="anonymous"></script>
</body>

</html>