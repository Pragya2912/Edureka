<html>
    <head>
        <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="Welcome to Edureka. A blog for coding enthusiasts">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <link rel="stylesheet" href="/css/style4.css">
    <title>Instructor-Led Online Training with 24X7 Lifetime Support | Edureka</title>
    <link rel="icon" type="image/png" href="/Images/image.png">
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <a class="navbar-brand" href="#">Edureka</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="/">Home <span class="sr-only">(current)</span></a>
                

                <li class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                        data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        Topics
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="#">Technology</a>
                        <a class="dropdown-item" href="#">Web Development</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="#">Support</a>
                        <a class="dropdown-item" href="#">Write for us</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="">Corporate Training</a>

                </li>
                
                <li class="nav-item">
                    <a class="nav-link" href="">Contact Us</a>
                </li>


            </ul>
            <form class="form-inline my-2 my-lg-0">
                <input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search">
                <button class="btn btn-outline-light my-2 my-sm-0" type="submit">Search</button>
            </form>
            <div class="mx-2">
                <button class="btn btn-danger"  ><a href="/form.html"> SignUP</a> </button>
                <!-- <button class="btn btn-danger"><a href="/form/Public/FORM.html">Signup</a></button> -->
            </div>
            <div class="mx-2">
                <button class="btn btn-danger"  ><a href="/login.html">Login</a> </button>
                <!-- <button class="btn btn-danger"><a href="/form/Public/FORM.html">Signup</a></button> -->
        </div>
    </nav>
    <div class="box1">
        <br>
        <h3>What is Algorithm?</h3>
        <hr>
        <br>
        <img src="/Images/daa5.png" alt="">
        <p>A finite set of instruction that specifies a sequence of operation is to be carried out in order to solve a specific problem or class of problems is called an Algorithm.</p>
        <h3>Why study Algorithm?</h3>
        <hr>
        <br>
        <p>As the speed of processor increases, performance is frequently said to be less central than other software quality characteristics (e.g. security, extensibility, reusability etc.). However, large problem sizes are commonplace in the area of computational science, which makes performance a very important factor. This is because longer computation time, to name a few mean slower results, less through research and higher cost of computation (if buying CPU Hours from an external party). The study of Algorithm, therefore, gives us a language to express performance as a function of problem size.</p>
        <h3>Characteristics of Algorithms</h3>
        <hr>
        <br>
        <img src="/Images/daa6.png" alt="">
        <br>
        <p><b>Input:</b>It should externally supply zero or more quantities.</p>
        <p><b>Output:</b> It results in at least one quantity.</p>
        <p><b>Definiteness:</b>Each instruction should be clear and ambiguous.</p>
        <p><b>Finiteness:</b>An algorithm should terminate after executing a finite number of steps.</p>
        <p><b>Effectiveness:</b>Every instruction should be fundamental to be carried out, in principle, by a person using only pen and paper.</p>
        <p><b>Feasible:</b> It must be feasible enough to produce each instruction.</p>
        <p><b>Flexibility: </b>It must be flexible enough to carry out desired changes with no efforts.</p>
        <p><b>Efficient:</b>The term efficiency is measured in terms of time and space required by an algorithm to implement. Thus, an algorithm must ensure that it takes little time and less memory space meeting the acceptable limit of development time.</p>
        <p><b>Independent:</b>An algorithm must be language independent, which means that it should mainly focus on the input and the procedure required to derive the output instead of depending upon the language.</p>
        <h3>Advantages of an Algorithm</h3>
        <hr>
        <br>
        <p><b>Effective Communication:</b>Since it is written in a natural language like English, it becomes easy to understand the step-by-step delineation of a solution to any particular problem.</p>
        <p><b>Easy Debugging:</b> A well-designed algorithm facilitates easy debugging to detect the logical errors that occurred inside the program.</p>
        <p><b>Easy and Efficient Coding:</b> An algorithm is nothing but a blueprint of a program that helps develop a program.</p>
        <p><b>Independent of Programming Language:</b>Since it is a language-independent, it can be easily coded by incorporating any high-level language.</p>
        <h3>Disadvantages of an Algorithm</h3>
        <hr>
        <br>
        <p>&bull; Developing algorithms for complex problems would be time-consuming and difficult to understand.</p>
        <p>&bull; It is a challenging task to understand complex logic through algorithms.</p>
        <h3>Pseudocode</h3>
        <hr>
        <br>
        <p>Pseudocode refers to an informal high-level description of the operating principle of a computer program or other algorithm. It uses structural conventions of a standard programming language intended for human reading rather than the machine reading.</p>
        <h3>Advantages of Pseudocode</h3>
        <hr>
        <br>
        <p>&bull;Since it is similar to a programming language, it can be quickly transformed into the actual programming language than a flowchart.</p>
        <p>&bull;The layman can easily understand it.</p>
        <p>&bull;Easily modifiable as compared to the flowcharts.</p>
        <p>&bull;Its implementation is beneficial for structured, designed elements.</p>
        <p>&bull;It can easily detect an error before transforming it into a code.</p>
        <h3>Disadvantages of Pseudocode</h3>
        <hr>
        <br>
        <p>&bull;Since it does not incorporate any standardized style or format, it can vary from one company to another.</p>
        <p>&bull;Error possibility is higher while transforming into a code.</p>
        <p>&bull;It may require a tool for extracting out the Pseudocode and facilitate drawing flowcharts.</p>
        <p>&bull;It does not depict the design.</p>
        <h3>Difference between Algorithm and the Pseudocode</h3>
        <hr>
        <br>
        <img src="/Images/daa7.jpg" alt="">
        <br>
        <p>An algorithm is simply a problem-solving process, which is used not only in computer science to write a program but also in our day to day life. It is nothing but a series of instructions to solve a problem or get to the problem's solution. It not only helps in simplifying the problem but also to have a better understanding of it.</p>
        <p>However, Pseudocode is a way of writing an algorithm. Programmers can use informal, simple language to write pseudocode without following any strict syntax. It encompasses semi-mathematical statements.</p>
        <h3>Need of Algorithm</h3>
        <hr>
        <br>
        <p>1. To understand the basic idea of the problem.</p>
        <p>2. To find an approach to solve the problem.</p>
        <p>3. To improve the efficiency of existing techniques.</p>
        <p>4. To understand the basic principles of designing the algorithms.</p>
        <p>5. To compare the performance of the algorithm with respect to other techniques.</p>
        <p>6. It is the best method of description without describing the implementation detail.</p>
        <p>7. The Algorithm gives a clear description of requirements and goal of the problem to the designer.</p>
        <p>8. A good design can produce a good solution.</p>
        <p>9. To understand the flow of the problem.</p>
        <p>10. To measure the behavior (or performance) of the methods in all cases (best cases, worst cases, average cases)</p>
        <p>11. With the help of an algorithm, we can also identify the resources (memory, input-output) cycles required by the algorithm.</p>
        <p>12. To understand the principle of designing.</p>
        <p>13. We can measure and analyze the complexity (time and space) of the problems concerning input size without implementing and running it; it will reduce the cost of design.</p>
        <h3>Analysis of algorithm</h3>
        <hr>
        <br>
        <p>The analysis is a process of estimating the efficiency of an algorithm. There are two fundamental parameters based on which we can analysis the algorithm:</p>
        <p><b>Space Complexity:</b>The space complexity can be understood as the amount of space required by an algorithm to run to completion.</p>
        <p><b>Time Complexity:</b>Time complexity is a function of input size n that refers to the amount of time needed by an algorithm to run to completion.</p>
        <p>Generally, we make three types of analysis, which is as follows:</p>
        <p><b>Worst-case time complexity: </b>For 'n' input size, the worst-case time complexity can be defined as the maximum amount of time needed by an algorithm to complete its execution. Thus, it is nothing but a function defined by the maximum number of steps performed on an instance having an input size of n.</p>
        <p><b>Average case time complexity:</b>For 'n' input size, the average-case time complexity can be defined as the average amount of time needed by an algorithm to complete its execution. Thus, it is nothing but a function defined by the average number of steps performed on an instance having an input size of n.</p>
        <p><b>Best case time complexity:</b>For 'n' input size, the best-case time complexity can be defined as the minimum amount of time needed by an algorithm to complete its execution. Thus, it is nothing but a function defined by the minimum number of steps performed on an instance having an input size of n.</p>
        <h3>Complexity of Algorithm</h3>
        <hr>
        <br>
        <p>The term algorithm complexity measures how many steps are required by the algorithm to solve the given problem. It evaluates the order of count of operations executed by an algorithm as a function of input data size.</p>
        <p>To assess the complexity, the order (approximation) of the count of operation is always considered instead of counting the exact steps.</p>
        <p>The complexity can be found in any form such as constant, logarithmic, linear, n*log(n), quadratic, cubic, exponential, etc. It is nothing but the order of constant, logarithmic, linear and so on, the number of steps encountered for the completion of a particular algorithm. To make it even more precise, we often call the complexity of an algorithm as "running time".</p>
        <h3>Typical Complexities of an Algorithm</h3>
        <hr>
        <br>
        <p><b>Constant Complexity:</b>It imposes a complexity of O(1). It undergoes an execution of a constant number of steps like 1, 5, 10, etc. for solving a given problem. The count of operations is independent of the input data size.</p>
        <p><b>Logarithmic Complexity:</b>It imposes a complexity of O(log(N)). It undergoes the execution of the order of log(N) steps. To perform operations on N elements, it often takes the logarithmic base as 2.
            For N = 1,000,000, an algorithm that has a complexity of O(log(N)) would undergo 20 steps (with a constant precision). Here, the logarithmic base does not hold a necessary consequence for the operation count order, so it is usually omitted.</p>
        <p><b>Linear Complexity:</b></p>
        <p>It imposes a complexity of O(N). It encompasses the same number of steps as that of the total number of elements to implement an operation on N elements.
            For example, if there exist 500 elements, then it will take about 500 steps. Basically, in linear complexity, the number of elements linearly depends on the number of steps. For example, the number of steps for N elements can be N/2 or 3*N.</p>
        <p>It also imposes a run time of O(n*log(n)). It undergoes the execution of the order N*log(N) on N number of elements to solve the given problem.
            For a given 1000 elements, the linear complexity will execute 10,000 steps for solving a given problem.</p>
        <p><b>Quadratic Complexity:</b>It imposes a complexity of O(n2). For N input data size, it undergoes the order of N2 count of operations on N number of elements for solving a given problem.
            If N = 100, it will endure 10,000 steps. In other words, whenever the order of operation tends to have a quadratic relation with the input data size, it results in quadratic complexity. For example, for N number of elements, the steps are found to be in the order of 3*N2/2.</p>
   
        <p><b>Cubic Complexity:</b>It imposes a complexity of O(n3). For N input data size, it executes the order of N3 steps on N elements to solve a given problem.
            For example, if there exist 100 elements, it is going to execute 1,000,000 steps.</p>
        <p><b>Exponential Complexity:</b>It imposes a complexity of O(2n), O(N!), O(nk), …. For N elements, it will execute the order of count of operations that is exponentially dependable on the input data size.</p>
        <p>For example, if N = 10, then the exponential function 2N will result in 1024. Similarly, if N = 20, it will result in 1048 576, and if N = 100, it will result in a number having 30 digits. The exponential function N! grows even faster; for example, if N = 5 will result in 120. Likewise, if N = 10, it will result in 3,628,800 and so on.</p>
        <p>Since the constants do not hold a significant effect on the order of count of operation, so it is better to ignore them. Thus, to consider an algorithm to be linear and equally efficient, it must undergo N, N/2 or 3*N count of operation, respectively, on the same number of elements to solve a particular problem</p>
        <h3>How to approximate the time taken by the Algorithm?</h3>
        <hr>
        <br>
        <p>So, to find it out, we shall first understand the types of the algorithm we have. There are two types of algorithms:</p>
        <p><b>Iterative Algorithm:</b>In the iterative approach, the function repeatedly runs until the condition is met or it fails. It involves the looping construct.</p>
        <p><b>Recursive Algorithm:</b>In the recursive approach, the function calls itself until the condition is met. It integrates the branching structure.</p>
        <p>But to analyze the iterative program, we have to count the number of times the loop is going to execute, whereas in the recursive program, we use recursive equations, i.e., we write a function of F(n) in terms of F(n/2).</p>
        <p>Suppose the program is neither iterative nor recursive. In that case, it can be concluded that there is no dependency of the running time on the input data size, i.e., whatever is the input size, the running time is going to be a constant value. Thus, for such programs, the complexity will be O(1).</p>
        <h3>Algorithm Design Techniques</h3>
        <hr>
        <br>
        <p>The following is a list of several popular design approaches:</p>
        <p><b>Divide and Conquer Approach:</b>It is a top-down approach. The algorithms which follow the divide & conquer techniques involve three steps:</p>
        <p>1) Divide the original problem into a set of subproblems.</p>
        <p>2) Solve every subproblem individually, recursively.</p>
        <p>3) Combine the solution of the subproblems (top level) into a solution of the whole original problem.</p>
        <p><b> Greedy Technique:</b>Greedy method is used to solve the optimization problem. An optimization problem is one in which we are given a set of input values, which are required either to be maximized or minimized (known as objective), i.e. some constraints or conditions.</p>
        <p>&bull; Greedy Algorithm always makes the choice (greedy criteria) looks best at the moment, to optimize a given objective.</p>
        <p>&bull; The greedy algorithm doesn't always guarantee the optimal solution however it generally produces a solution that is very close in value to the optimal.</p>
        <p><b>Dynamic Programming:</b>Dynamic Programming is a bottom-up approach we solve all possible small problems and then combine them to obtain solutions for bigger problems.</p>
        <p>This is particularly helpful when the number of copying subproblems is exponentially large. Dynamic Programming is frequently related to Optimization Problems. </p>
        <p><b>Branch and Bound:</b>In Branch & Bound algorithm a given subproblem, which cannot be bounded, has to be divided into at least two new restricted subproblems. Branch and Bound algorithm are methods for global optimization in non-convex problems. Branch and Bound algorithms can be slow, however in the worst case they require effort that grows exponentially with problem size, but in some cases we are lucky, and the method coverage with much less effort.</p>
        <p><b> Randomized Algorithms:</b> A randomized algorithm is defined as an algorithm that is allowed to access a source of independent, unbiased random bits, and it is then allowed to use these random bits to influence its computation.</p>
        <p><b>Backtracking Algorithm:</b>Backtracking Algorithm tries each possibility until they find the right one. It is a depth-first search of the set of possible solution. During the search, if an alternative doesn't work, then backtrack to the choice point, the place which presented different alternatives, and tries the next alternative. </p>
        <h3>Asymptotic Analysis of algorithms (Growth of function) </h3>
        <hr>
        <br>
        <p>Resources for an algorithm are usually expressed as a function regarding input. Often this function is messy and complicated to work. To study Function growth efficiently, we reduce the function down to the important part.</p>
        <p> Let f (n) = an2+bn+c</p>
        <p>In this function, the n2 term dominates the function that is when n gets sufficiently large.

            Dominate terms are what we are interested in reducing a function, in this; we ignore all constants and coefficient and look at the highest order term concerning n.</p>
         <h3>Asymptotic notation</h3>
         <hr>
         <br>
         <p>The word Asymptotic means approaching a value or curve arbitrarily closely (i.e., as some sort of limit is taken).</p>
         <p><b>Asymptotic analysis</b></p>
         <p>It is a technique of representing limiting behavior. The methodology has the applications across science. It can be used to analyze the performance of an algorithm for some large data set.</p>
         <p>In computer science in the analysis of algorithms, considering the performance of algorithms when applied to very large input datasets</p>
         <p>The simplest example is a function ƒ (n) = n2+3n, the term 3n becomes insignificant compared to n2 when n is very large. The function "ƒ (n) is said to be asymptotically equivalent to n2 as n → ∞", and here is written symbolically as ƒ (n) ~ n2.</p>
         <p>Asymptotic notations are used to write fastest and slowest possible running time for an algorithm. These are also referred to as 'best case' and 'worst case' scenarios respectively. </p>
         <p>"In asymptotic notations, we derive the complexity concerning the size of the input. (Example in terms of n)"

            "These notations are important because without expanding the cost of running the algorithm, we can estimate the complexity of the algorithms."</p>
   
         <h3>Why is Asymptotic Notation Important?</h3>
         <hr>
         <br>
         <p>1)  They give simple characteristics of an algorithm's efficiency.</p>
         <p>2)  They allow the comparisons of the performances of various algorithms.</p>
         <h3>Asymptotic Notations</h3>
         <hr>
         <br>
         <p>Asymptotic Notation is a way of comparing function that ignores constant factors and small input sizes. Three notations are used to calculate the running time complexity of an algorithm:</p>
         <p><b>Big-oh notation:</b>Big-oh is the formal method of expressing the upper bound of an algorithm's running time. It is the measure of the longest amount of time. The function f (n) = O (g (n)) [read as "f of n is big-oh of g of n"] if and only if exist positive constant c and such that

            f (n) ⩽ k.g (n)f(n)⩽k.g(n) for n>n0n>n0 in all case   </p>
            <p>Hence, function g (n) is an upper bound for function f (n), as g (n) grows faster than f (n)</p>
            <img src="/Images/daa.png" alt="">
            <br>
            <br>

            <p><b> Omega () Notation:</b>The function f (n) = Ω (g (n)) [read as "f of n is omega of g of n"] if and only if there exists positive constant c and n0 such that F (n) ≥ k* g (n) for all n, n≥ n0

            </p>
            <br>
            <img src="/Images/daa2.png" alt="">
          <p><b>Theta (θ):</b> The function f (n) = θ (g (n)) [read as "f is the theta of g of n"] if and only if there exists positive constant k1, k2 and k0 such that

            k1 * g (n) ≤ f(n)≤ k2 g(n)for all n, n≥ n0
          </p>
          <br>
          <img src="/Images/daa3.png" alt="">
          <br>
          <br>
          <h3>Recurrence Relation</h3>
          <hr>
          <br>
          <p>A recurrence is an equation or inequality that describes a function in terms of its values on smaller inputs. To solve a Recurrence Relation means to obtain a function defined on the natural numbers that satisfy the recurrence.</p>
          <p>here are four methods for solving Recurrence:</p>
          <p>&bull; Substitution Method</p>
          <p>&bull; Iteration Method</p>
          <p>&bull; Recursion Tree Method</p>
          <p>&bull; Master Method</p>
          <h3>Types of Sorting</h3>
          <hr>
          <br>
          <p>&bull; Bubble Sort</p>
          <p>&bull; Selection Sort</p>
          <p>&bull; Insertion Sort</p>
   
   
        </div>
        <hr>
        <br>
        <footer class="container">
           <p class="float-right"><a href="#">Back to top</a></p>
           <p>© 2022-2023 Edureka, Inc. · <a href="#">Privacy</a> · <a
                   href="#">Terms</a>
           </p>
           </footer>
           <!-- Optional JavaScript -->
           <!-- jQuery first, then Popper.js, then Bootstrap JS -->
           <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
           integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
           crossorigin="anonymous"></script>
           <script
           src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
           integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
           crossorigin="anonymous"></script>
           <script
           src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
           integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
           crossorigin="anonymous"></script>
           </body>
           </html>