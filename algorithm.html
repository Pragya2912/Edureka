<html>
    <head>
        <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="Welcome to Edureka. A blog for coding enthusiasts">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <link rel="stylesheet" href="/css/style4.css">
       <title>Instructor-Led Online Training with 24X7 Lifetime Support | Edureka</title>
    <link rel="icon" type="image/png" href="/Images/image.png">
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <a class="navbar-brand" href="/">Edureka</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="/">Home <span class="sr-only">(current)</span></a>
                

               
               <li class="nav-item">
                    <a class="nav-link" href="/training.html">Corporate Training</a>

                </li>
                
                <li class="nav-item">
                    <a class="nav-link" href="/contact.html">Contact Us</a>
                </li>


            </ul>
            
            <div class="mx-2">
                <button class="btn btn-danger"  ><a href="/form.html"> SignUP</a> </button>
                <!-- <button class="btn btn-danger"><a href="/form/Public/FORM.html">Signup</a></button> -->
            </div>
            <div class="mx-2">
                <button class="btn btn-danger"  ><a href="/login.html">Login</a> </button>
                <!-- <button class="btn btn-danger"><a href="/form/Public/FORM.html">Signup</a></button> -->
        </div>
    </nav>
    <div class="box1">
        <h2>What is Algorithm | Introduction to Algorithms</h2>
        <hr>
        <br>
        <img src="/Images/algorithm.jpg" alt="">
        <p>The word Algorithm means ” A  set of rules to be followed in calculations or other problem-solving operations ” Or ” A procedure for solving a mathematical problem in a finite number of steps that frequently involves recursive operations”. </p>
        <p>Therefore Algorithm refers to a sequence of finite steps to solve a particular problem.

            Algorithms can be simple and complex depending on what you want to achieve.</p>
        
         <h2>What are the Characteristics of an Algorithm?</h2>
         <hr>
         <br>
         <img src="/Images/algorithm2.jpg" alt="">
         <br>
         <p>&bull;<b>Clear and Unambiguous:</b> The algorithm should be clear and unambiguous. Each of its steps should be clear in all aspects and must lead to only one meaning.</p>
         <p>&bull;<b>Well-Defined Inputs: </b>If an algorithm says to take inputs, it should be well-defined inputs</p>
         <p>&bull; <b>Well-Defined Outputs:</b>The algorithm must clearly define what output will be yielded and it should be well-defined as well. </p>
        <p>&bull;<b>Finite-ness:</b>The algorithm must be finite, i.e. it should terminate after a finite time</p>
        <p>&bull;<b>Feasible: </b>The algorithm must be simple, generic, and practical, such that it can be executed with the available resources. It must not contain some future technology or anything.</p>
        <p>&bull;<b>Language Independent:</b>The Algorithm designed must be language-independent, i.e. it must be just plain instructions that can be implemented in any language, and yet the output will be the same, as expected.</p>
        <h2>Properties of Algorithm</h2>
        <hr>
        <br>
        <p> &bull;It should terminate after a finite time.</p>
        <p> &bull;It should produce at least one output.</p>
        <p> &bull;It should take zero or more input.</p>
        <p> &bull;It should be deterministic means giving the same output for the same input case.</p>
        <p>&bull;Every step in the algorithm must be effective i.e. every step should do some work.</p>
        <h2>Types of Algorithms</h2>
        <hr>
        <br>
        <img src="/Images/algorithm3.png" alt="">
        <br>
        <p>1) <b>Brute Force Algorithm: </b>It is the simplest approach for a problem. A brute force algorithm is the first approach that comes to finding when we see a problem.</p>
        <p>2) <b>Recursive Algorithm:</b>A recursive algorithm is based on recursion. In this case, a problem is broken into several sub-parts and called the same function again and again</p>
        <p>3)<b> Backtracking Algorithm:</b>The backtracking algorithm basically builds the solution by searching among all possible solutions. Using this algorithm, we keep on building the solution following criteria. Whenever a solution fails we trace back to the failure point and build on the next solution and continue this process till we find the solution or all possible solutions are looked after.</p>
        <p>4) <b>Searching Algorithm: </b>Searching algorithms are the ones that are used for searching elements or groups of elements from a particular data structure. They can be of different types based on their approach or the data structure in which the element should be found.</p>
        <p>5) <b>Sorting Algorithm: </b>Sorting is arranging a group of data in a particular manner according to the requirement. The algorithms which help in performing this function are called sorting algorithms. Generally sorting algorithms are used to sort groups of data in an increasing or decreasing manner.</p>
        <p>6)<b>Hashing Algorithm: </b>Hashing algorithms work similarly to the searching algorithm. But they contain an index with a key ID. In hashing, a key is assigned to specific data.</p>
        <p>7)<b> Divide and Conquer Algorithm:</b> This algorithm breaks a problem into sub-problems, solves a single sub-problem and merges the solutions together to get the final solution. It consists of the following three steps:</p>

        <p> &bull;Divide</p>
        <p> &bull;Solve</p>
        <p> &bull;Combine</p>
    <p>8)<b> Greedy Algorithm:</b> In this type of algorithm the solution is built part by part. The solution of the next part is built based on the immediate benefit of the next part. The one solution giving the most benefit will be chosen as the solution for the next part.</p>
    <p>9)<b>Dynamic Programming Algorithm:</b> This algorithm uses the concept of using the already found solution to avoid repetitive calculation of the same part of the problem. It divides the problem into smaller overlapping subproblems and solves them.</p>
    <p>10)<b>Randomized Algorithm: </b>In the randomized algorithm we use a random number so it gives immediate benefit. The random number helps in deciding the expected outcome.</p>
    <h2>Advantages of Algorithms</h2>
    <hr>
    <br>
    <p> &bull;It is easy to understand.</p>
    <p> &bull;An algorithm is a step-wise representation of a solution to a given problem.</p>
    <p> &bull;In Algorithm the problem is broken down into smaller pieces or steps hence, it is easier for the programmer to convert it into an actual program.</p>
    <h2>Disadvantages of Algorithms</h2>
    <hr>
    <br>
    <p>&bull;Writing an algorithm takes a long time so it is time-consuming.</p>
    <p>&bull;Understanding complex logic through algorithms can be very difficult.</p>
    <p> &bull; Branching and Looping statements are difficult to show in Algorithm</p>
    <h2>Algorithm complexity </h2>
    <hr>
    <br>
    <p>An algorithm is defined as complex based on the amount of Space and Time it consumes. Hence the Complexity of an algorithm refers to the measure of the Time that it will need to execute and get the expected output, and the Space it will need to store all the data (input, temporary data and output). Hence these two factors define the efficiency of an algorithm. </p>
     <p>&bull; <b>The two factors of Algorithm Complexity are:</b></p>
     <p>&bull; <b>Time Factor: </b>Time is measured by counting the number of key operations such as comparisons in the sorting algorithm.</p>
     <p>&bull; <b>Space Factor:</b> Space is measured by counting the maximum memory space required by the algorithm</p>
     <p><b>Therefore the complexity of an algorithm can be divided into two types:</b></p>
     <p>1) <b>Space Complexity: </b>The space complexity of an algorithm refers to the amount of memory used by the algorithm to store the variables and get the result. This can be for inputs, temporary operations, or outputs. </p>
     <p><b>How to calculate Space Complexity?</b></p>
     <p>The space complexity of an algorithm is calculated by determining the following 2 components: </p>
     <p>&bull;<b>Fixed Part: </b>This refers to the space that is definitely required by the algorithm. For example, input variables, output variables, program size, etc</p>
     <p>&bull;<b>Variable Part:</b>This refers to the space that can be different based on the implementation of the algorithm. For example, temporary variables, dynamic memory allocation, recursion stack space, etc.
        Therefore Space complexity S(P) of any algorithm P is S(P) = C + SP(I), where C is the fixed part and S(I) is the variable part of the algorithm, which depends on instance characteristic I.</p>
     <p>2)<b> Time Complexity:</b> The time complexity of an algorithm refers to the amount of time that is required by the algorithm to execute and get the result. This can be for normal operations, conditional if-else statements, loop statements, etc.</p>
    <p><b>How to calculate Time Complexity?</b></p>
    <p>The time complexity of an algorithm is also calculated by determining the following 2 components: </p>
  <p>&bull; <b>Constant time part:</b> Any instruction that is executed just once comes in this part. For example, input, output, if-else, switch, etc.</p>
 <p> &bull;<b>Variable Time Part:</b> Any instruction that is executed more than once, say n times, comes in this part. For example, loops, recursion, etc.
    Therefore Time complexity T(P) of any algorithm P is T(P) = C + TP(I), where C is the constant time part and TP(I) is the variable part of the algorithm, which depends on the instance characteristic I.</p>
<h3>Creating an Algorithm</h3>
<hr>
<br>
<p>Since the algorithm is language-independent, we write the steps to demonstrate the logic behind the solution to be used for solving a problem. But before writing an algorithm, keep the following points in mind:</p>
<p>&bull; The algorithm should be clear and unambiguous.</p>
<p>&bull; There should be 0 or more well-defined inputs in an algorithm.</p>
<p>&bull; An algorithm must produce one or more well-defined outputs that are equivalent to the desired output. After a specific number of steps, algorithms must ground to a halt.</p>
<p>&bull; Algorithms must stop or end after a finite number of steps.</p>
<p>&bull; In an algorithm, step-by-step instructions should be supplied, and they should be independent of any computer code.</p>
<p><b>Example: </b>algorithm to multiply 2 numbers and print the result:</p>
<p>  <b>Step 1:</b> Start</p>
<p><b> Step 2:</b> Get the knowledge of input. Here we need 3 variables; a and b will be the user input and c will hold the result.  
    <p>  <b> Step 3:</b> Declare a, b, c variables.</p>
        <p>  <b> Step 4: </b>Take input for a and b variable from the user.</p>
            <p>  <b> Step 5:</b> Know the problem and find the solution using operators, data structures and logic</p>

    We need to multiply a and b variables so we use * operator and assign the result to c. 
    That is c &lt;- a * b</p>

    <p> <b>Step 6: </b>Check how to give output, Here we need to print the output. So write print c</p>
        <p> <b> Step 7:</b> End</p>
        <h3>Algorithm Analysis</h3>
        <hr>
        <br>
        <p>Algorithm analysis is an important part of computational complexity theory, which provides theoretical estimation for the required resources of an algorithm to solve a specific computational problem. Analysis of algorithms is the determination of the amount of time and space resources required to execute it.</p>
        <p><b>Why Analysis of Algorithms is important?</b></p>
        <p> &bull;To predict the behavior of an algorithm without implementing it on a specific computer.</p>
        <p> &bull;It is much more convenient to have simple measures for the efficiency of an algorithm than to implement the algorithm and test the efficiency every time a certain parameter in the underlying computer system changes.</p>
        <p>  &bull;It is impossible to predict the exact behavior of an algorithm. There are too many influencing factors.</p>
        <p>  &bull;The analysis is thus only an approximation; it is not perfect.</p>
        <p> &bull; More importantly, by analyzing different algorithms, we can compare them to determine the best one for our purpose.</p>
        <p><b>Types of Algorithm Analysis</b></p>
        <p> 1)Best case </p>
          <p> 2)Worst case</p>
           <p>3) Average case</p>
           <p><b>Best case: </b>Define the input for which algorithm takes less time or minimum time. In the best case calculate the lower bound of an algorithm. Example: In the linear search when search data is present at the first location of large data then the best case occurs.</p>
            <p><b>Worst Case:</b> Define the input for which algorithm takes a long time or maximum time. In the worst calculate the upper bound of an algorithm. Example: In the linear search when search data is not present at all then the worst case occurs.</p>
             <p><b>Average case:</b> In the average case take all random inputs and calculate the computation time for all inputs.
                And then we divide it by the total number of inputs.</p>

    </div>
    <br>
    <hr>
    <br>
<footer class="container">
<p class="float-right"><a href="#">Back to top</a></p>
<p>© 2022-2023 Edureka, Inc. · <a href="#">Privacy</a> · <a
        href="#">Terms</a>
</p>
</footer>
<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
crossorigin="anonymous"></script>
<script
src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
crossorigin="anonymous"></script>
<script
src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
integrity="sha384-/a"
crossorigin="anonymous"></script>
</body>
</html>